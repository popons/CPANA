/*
 * aestest.c - test AES functions
 * $Id: omactest.c,v 1.1 2006-04-07 03:06:19 kensaku Exp $
 */

/*
 * based on test vectors at:
 * http://crypt.cis.ibaraki.ac.jp/omac/omac.html
 */

/*
 * Usage: omactest [-v][-d]
 * Options:
 *   -v    prints short progress messages.
 *   -d    prints test values in a format similar with one in rijndael-vals.
 * Exit Status:
 *   0     passed all tests successfully.
 *   1     found errors.
 *
 * Build: cc -I.. -o omactest omactest.c ./.libs/libclpe.a
 */

#include <sys/types.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <clpe/omac.h>
#include <clpe/aes.h>

struct omac_test_msg {
  size_t msglen;
  unsigned char msg[64];
  unsigned char tag[16];
};

static unsigned char omac_test_key[16] = {0x2b, 0x7e, 0x15, 0x16,
					  0x28, 0xae, 0xd2, 0xa6,
					  0xab, 0xf7, 0x15, 0x88,
					  0x09, 0xcf, 0x4f, 0x3c};

#define OMAC1_TESTS_SIZE 4
static struct omac_test_msg omac1_tests[OMAC1_TESTS_SIZE] = {
  {				/* [0] */
    0,
    {},
    { 0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28,
      0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46 }
  }, {				/* [1] */
    16,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a },
    { 0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
      0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c }
  }, {				/* [2] */
    40,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
      0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11 },
    { 0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30,
      0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27 }
  }, {				/* [3] */
    64,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
      0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
      0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
      0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
      0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 },
    { 0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
      0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe }
  }
};

#define OMAC2_TESTS_SIZE 4
static struct omac_test_msg omac2_tests[OMAC2_TESTS_SIZE] = {
  {				/* [0] */
    0,
    {},
    { 0xf6, 0xbc, 0x6a, 0x41, 0xf4, 0xf8, 0x45, 0x93,
      0x80, 0x9e, 0x59, 0xb7, 0x19, 0x29, 0x9c, 0xfe }
  }, {				/* [1] */
    16,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a },
    { 0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44,
      0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c }
  }, {				/* [2] */
    40,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
      0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11 },
    { 0x23, 0xfd, 0xaa, 0x08, 0x31, 0xcd, 0x31, 0x44,
      0x91, 0xce, 0x4b, 0x25, 0xac, 0xb6, 0x02, 0x3b }
  }, {				/* [3] */
    64,
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
      0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
      0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
      0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
      0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
      0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
      0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
      0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 },
    { 0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
      0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe }
  }
};

static char *
hexstr(unsigned char *data, size_t len)
{
  static char buf[1024];
  char *p;
  int i;
  if (len * 2 + 1 > sizeof(buf)) {
    fprintf(stderr, "%s: %d: too long data\n", __FILE__, __LINE__);
    abort();
  }
  for (i = 0, p = buf; i < len; i++, p += 2) {
    sprintf(p, "%02x", data[i] & 0xff);
  }

  return buf;
}

static int
mac_aes128(int verbose, clpe_omac_algorithm_t alg)
{
  uint8_t tag[16];
  clpe_omac_t *ctx;
  int nerrs, i;
  size_t ntests;
  struct omac_test_msg *tests;
  clpe_aes_ctx_t aes_ctx;

  nerrs = 0;

  switch (alg) {
  case CLPE_OMAC1:
    tests = omac1_tests;
    ntests = OMAC1_TESTS_SIZE;
    break;
  case CLPE_OMAC2:
    tests = omac2_tests;
    ntests = OMAC2_TESTS_SIZE;
    break;
  default:
    fprintf(stderr, "invalid OMAC algorithm\n");
    abort();
  }

  memset(&aes_ctx, 0, sizeof(aes_ctx));

  ctx = clpe_omac_new(CLPE_AES_BLOCK_SIZE,
		      (clpe_blkciph_encrypt_func_t)clpe_aes_enc_blk,
		      (void *)&aes_ctx);
  if (ctx == NULL)
    return 0;

  clpe_aes_enc_key(omac_test_key, 16, &aes_ctx); /* 128 bit key */

  clpe_omac_init(ctx, alg);

  for (i = 0; i < ntests; i++) {
    clpe_omac_restart(ctx);	/* unnecessary for i=0, but does not harm */
    clpe_omac_add(ctx, tests[i].msg, tests[i].msglen);
    clpe_omac_final(ctx, tag, sizeof(tag));
    if (verbose) {
      printf("OMAC1-AES128 [ K , msg[%2u] ] = %s\n",
	     tests[i].msglen,
	     hexstr(tag, sizeof(tag)));
    }
    if (memcmp(tag, tests[i].tag, 16) != 0) {
      if (verbose)
	printf("*** error found ***\n");
      nerrs++;
    }
  }

  clpe_omac_destroy(ctx);
  
  return nerrs == 0;
}

int
dotest(int (*func)(int, clpe_omac_algorithm_t), clpe_omac_algorithm_t alg,
       char *desc, int verbose, int debug)
{
  int result;

  if (verbose) {
    if (debug) {
      printf("=========================\n");
      printf("%s\n", desc);
      printf("=========================\n");
    } else {
      printf("%s ... ", desc);
      fflush(stdout);
    }
  }

  result = (*func)(debug, alg);

  if (verbose) {
    if (debug) {
      printf("\n=========================\n");
      printf("%s\n", desc);
      printf("RESULT: %s\n", result ? "OK" : "ERROR");
      printf("=========================\n\n");
    } else {
      printf("%s\n", result ? "ok" : "ERROR");
    }
  }

  return result;
}

int
main(int argc, char **argv)
{
  int verbose, debug;
  int result, errorcount;
  char *progname;

  progname = argv[0];

  verbose = debug = 0;
  while (argc > 1) {
    if (strcmp(argv[1], "-d") == 0)
      debug = 1;
    else if (strcmp(argv[1], "-v") == 0)
      verbose = 1;
    else {
      fprintf(stderr, "Usage: %s [-d][-v]\n", progname);
      exit(2);
    }
    argc--;
    argv++;
  }

  if (!dotest(mac_aes128, CLPE_OMAC1, "OMAC1-AES128",
	      verbose, debug))
    errorcount++;
  if (!dotest(mac_aes128, CLPE_OMAC2, "OMAC2-AES128",
	      verbose, debug))
    errorcount++;

  return errorcount ? 1 : 0;
}
